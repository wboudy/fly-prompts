#!/usr/bin/env python3
from __future__ import annotations

import json
from pathlib import Path

from prompt_contract import collect_prompts

ROOT = Path(__file__).resolve().parent.parent
BLOCKS_DIR = ROOT / "src" / "blocks"
PROMPTS_DIR = ROOT / "src" / "prompts"
OUTPUT_PATH = ROOT / "command_palette.md"

MACRO_BLOCKS = {
    "{{PREAMBLE}}": BLOCKS_DIR / "preamble.md",
    "{{REPORTBACK}}": BLOCKS_DIR / "reportback.md",
}

HEADER = """# Command Palette

<!-- Generated by scripts/build_palette.py. Do not edit manually. -->
<!-- Source of truth: src/prompts/*.md frontmatter only (no legacy section). -->
"""

INDEX_BEGIN = "<!-- BEGIN GENERATED COMMAND INDEX -->"
INDEX_END = "<!-- END GENERATED COMMAND INDEX -->"


def _read(path: Path) -> str:
    return path.read_text(encoding="utf-8")


def _load_macros() -> dict[str, str]:
    macros: dict[str, str] = {}
    for placeholder, path in MACRO_BLOCKS.items():
        if not path.exists():
            raise FileNotFoundError(f"Missing macro block file: {path}")
        macros[placeholder] = _read(path).strip("\n")
    return macros


def _expand_macros(text: str, macros: dict[str, str]) -> str:
    expanded = text
    for placeholder, block_content in macros.items():
        expanded = expanded.replace(placeholder, block_content)
    return expanded


def _render_command_index(entries: list[dict[str, str]]) -> str:
    payload = json.dumps(entries, indent=2, ensure_ascii=True)
    return "\n".join(
        [
            "## Generated Command Index",
            "",
            "<!-- Source of truth: src/prompts/*.md frontmatter only. -->",
            INDEX_BEGIN,
            "```json",
            payload,
            "```",
            INDEX_END,
        ]
    )


def build_palette() -> str:
    macros = _load_macros()
    records, errors = collect_prompts(PROMPTS_DIR, ROOT)
    if errors:
        details = "\n".join(f"- {error}" for error in errors)
        raise ValueError(f"Prompt contract errors:\n{details}")

    included_records = [record for record in records if record.include_in_palette]
    prompt_sections: list[str] = []
    command_index_entries: list[dict[str, str]] = []

    for record in included_records:
        prompt_text = record.body.strip("\n")
        prompt_sections.append(_expand_macros(prompt_text, macros))
        command_index_entries.append(
            {
                "command_key": record.command_key,
                "stage": record.stage,
                "title": record.title,
                "source": record.rel_path,
            }
        )

    parts: list[str] = [HEADER.strip("\n"), _render_command_index(command_index_entries)]
    if prompt_sections:
        parts.append("\n\n".join(prompt_sections).strip("\n"))

    return "\n\n".join(parts) + "\n"


def main() -> int:
    try:
        OUTPUT_PATH.write_text(build_palette(), encoding="utf-8")
    except Exception as error:  # noqa: BLE001 - script-level surfacing is intentional
        print(f"ERROR: {error}")
        return 1

    print(f"Wrote {OUTPUT_PATH}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
