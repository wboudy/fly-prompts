#!/usr/bin/env python3
from __future__ import annotations

from pathlib import Path

ROOT = Path(__file__).resolve().parent.parent
BLOCKS_DIR = ROOT / "src" / "blocks"
PROMPTS_DIR = ROOT / "src" / "prompts"
LEGACY_PATH = ROOT / "src" / "legacy" / "command_palette.legacy.md"
OUTPUT_PATH = ROOT / "command_palette.md"

MACRO_BLOCKS = {
    "{{PREAMBLE}}": BLOCKS_DIR / "preamble.md",
    "{{REPORTBACK}}": BLOCKS_DIR / "reportback.md",
}

HEADER = """# Command Palette

<!-- Generated by scripts/build_palette.py. Do not edit manually. -->
"""


def _read(path: Path) -> str:
    return path.read_text(encoding="utf-8")


def _load_macros() -> dict[str, str]:
    macros: dict[str, str] = {}
    for placeholder, path in MACRO_BLOCKS.items():
        if not path.exists():
            raise FileNotFoundError(f"Missing macro block file: {path}")
        macros[placeholder] = _read(path).strip("\n")
    return macros


def _expand_macros(text: str, macros: dict[str, str]) -> str:
    expanded = text
    for placeholder, block_content in macros.items():
        expanded = expanded.replace(placeholder, block_content)
    return expanded


def _prompt_files() -> list[Path]:
    return sorted(p for p in PROMPTS_DIR.glob("*.md") if p.is_file())


def build_palette() -> str:
    macros = _load_macros()
    prompt_sections: list[str] = []

    for prompt_path in _prompt_files():
        prompt_text = _read(prompt_path).strip("\n")
        prompt_sections.append(_expand_macros(prompt_text, macros))

    legacy_text = _read(LEGACY_PATH)

    parts: list[str] = [HEADER.strip("\n")]
    if prompt_sections:
        parts.append("\n\n".join(prompt_sections).strip("\n"))

    parts.append("## Legacy Palette\n\n<!-- Preserved verbatim legacy command palette content. -->")
    parts.append(legacy_text.rstrip("\n"))
    return "\n\n".join(parts) + "\n"


def main() -> None:
    OUTPUT_PATH.write_text(build_palette(), encoding="utf-8")
    print(f"Wrote {OUTPUT_PATH}")


if __name__ == "__main__":
    main()
